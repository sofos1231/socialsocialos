<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Middleware — Auto‑Wiring Dashboard (v2)</title>
<style>
  :root{--bg:#0f1220;--panel:#141a33;--text:#e8ecf7;--muted:#9aa7b4;--border:rgba(255,255,255,.1)}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:#0f1220;color:var(--text);font:14px/1.35 system-ui,Segoe UI,Inter,sans-serif;display:flex}
  header{display:flex;gap:8px;align-items:center;padding:10px;border-bottom:1px solid var(--border);position:sticky;top:0;z-index:5;background:#141a33}
  .layout{display:grid;grid-template-columns:360px 1fr 440px;gap:10px;padding:10px;flex:1}
  .col{border:1px solid var(--border);border-radius:14px;background:#141a33;overflow:auto}
  .col h3{margin:0;padding:10px 12px;border-bottom:1px solid var(--border)}
  .section{padding:10px 12px;border-bottom:1px dashed var(--border)}
  .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  input,select,textarea,button{background:#0d1330;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px}
  textarea{width:100%;min-height:160px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  button{cursor:pointer}
  .status{display:inline-flex;gap:6px;align-items:center;padding:2px 8px;border:1px solid var(--border);border-radius:999px;font-size:12px}
  .ok{background:rgba(63,185,80,.15);border-color:rgba(63,185,80,.35)}
  .warn{background:rgba(210,153,34,.15);border-color:rgba(210,153,34,.35)}
  .err{background:rgba(248,81,73,.15);border-color:rgba(248,81,73,.35)}
  .listItem{padding:8px;border:1px solid var(--border);border-radius:10px;background:#0e1530;margin:6px 0}
  .muted{color:var(--muted);font-size:12px}
  .diff{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0a1227;border:1px solid var(--border);border-radius:10px;padding:8px;max-height:200px;overflow:auto}
  .tag{display:inline-block;padding:2px 8px;border:1px solid var(--border);border-radius:999px;font-size:12px;margin-right:6px;background:#0b1632}
</style>
</head>
<body>
  <div style="display:flex;flex-direction:column;width:100%">
    <header>
      <div style="font-weight:800">Middleware — Auto‑Wiring (v2)</div>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <span id="health" class="status warn">Scan to begin</span>
        <button id="scan">Scan FE ↔ MW</button>
        <button id="autoWire" disabled>Auto‑Wire Selected</button>
        <button id="applyPatch" disabled>Apply Patch</button>
        <button id="exportBundle" disabled>Export Bundle</button>
        <button id="selfTests">Self‑Tests</button>
        <button id="reset">Reset</button>
      </div>
    </header>

    <div class="layout">
      <aside class="col">
        <h3>Needs Attention</h3>
        <div class="section muted">Scan → select → Auto‑Wire → Apply Patch.</div>
        <div class="section" id="queue"></div>
        <h3>Inference Settings</h3>
        <div class="section">
          <div class="row"><label class="muted">Default method</label><select id="infMethod"><option>GET</option><option>POST</option></select></div>
          <div class="row"><label class="muted">Mapping overrides (one per line: <code>componentId → GET_/path</code>)</label></div>
          <textarea id="mapOverrides" placeholder="PracticeCard:list → GET_/missions"></textarea>
          <div class="row"><button id="saveSettings">Save Settings</button><span class="muted">Stored locally</span></div>
        </div>
      </aside>

      <main class="col">
        <h3>Patch Preview</h3>
        <div class="section" id="patch"></div>
        <div class="section" id="bePatch"></div>
      </main>

      <aside class="col">
        <h3>Spec, Mocks & Logs</h3>
        <div class="section">
          <div class="row"><button id="viewSpec">View OpenAPI</button><button id="viewMocks">View Mocks</button><button id="viewWiring">View Wiring</button><button id="viewBE">View BE Files</button></div>
          <textarea id="viewer" placeholder="Click a button to view current data" readonly></textarea>
        </div>
        <div class="section">
          <div class="muted">Telemetry</div>
          <div id="telemetry" class="diff">ops: 0 | mocks: 0 | wiring: 0 | beFiles: 0 | errors: 0</div>
        </div>
        <div class="section">
          <div class="muted">Event Log</div>
          <pre id="log" class="diff">(empty)</pre>
        </div>
      </aside>
    </div>
  </div>

<script>
(function(){
  function $(s){ return document.querySelector(s); }
  function el(t,a,c){ var n=document.createElement(t); a=a||{}; c=c||[]; for(var k in a){ var v=a[k]; if(k==='class'){ n.className=v; } else if(k==='text'){ n.textContent=v; } else if(k.indexOf('on')===0){ n.addEventListener(k.slice(2),v); } else { n.setAttribute(k,v); } } (Array.isArray(c)?c:[c]).forEach(function(x){ if(!x) return; n.appendChild(typeof x==='string'?document.createTextNode(x):x); }); return n; }

  var SCHEMA_VERSION=1;
  var KEYS={ MW:'mw.spec', FE:'fe.contracts', VISUAL_FE:'fe.visual.editor.pages', BE:'be.scaffold', SETTINGS:'mw.settings', WIRING:'wiring.matrix' };

  function loadJSON(key, fallback){ try{ var raw=localStorage.getItem(key); if(!raw) return fallback; return JSON.parse(raw); }catch(e){ return fallback; } }
  function saveJSON(key, value){ localStorage.setItem(key, JSON.stringify(value)); }
  function clone(x){ return JSON.parse(JSON.stringify(x)); }

  function loadMW(){ var mw=loadJSON(KEYS.MW,null); if(!mw){ mw={version:SCHEMA_VERSION, openapi:{openapi:'3.1.0',info:{title:'Contracts',version:'0.1.0'},paths:{}}, mocks:{}}; saveJSON(KEYS.MW,mw);} if(!mw.version) mw.version=SCHEMA_VERSION; mw.openapi.paths=mw.openapi.paths||{}; mw.mocks=mw.mocks||{}; return mw; }
  function saveMW(mw){ saveJSON(KEYS.MW,mw); }

  function loadSettings(){ var s=loadJSON(KEYS.SETTINGS,{version:SCHEMA_VERSION,method:'GET',mapOverrides:''}); if(!s.version) s.version=SCHEMA_VERSION; return s; }
  function saveSettings(s){ saveJSON(KEYS.SETTINGS,s); }

  function loadBE(){ var be=loadJSON(KEYS.BE,{version:SCHEMA_VERSION,files:{}}); if(!be.version) be.version=SCHEMA_VERSION; be.files=be.files||{}; return be; }
  function saveBE(be){ saveJSON(KEYS.BE,be); }

  function loadFE(){ var fe=loadJSON(KEYS.FE,null); if(fe&&fe.components) return fe; var pages=loadJSON(KEYS.VISUAL_FE,null); if(pages){ var components=[], screens=[]; Object.keys(pages).forEach(function(page){ screens.push({id:page}); (pages[page]||[]).forEach(function(c){ components.push({id:c.id, screen:page, title:c.id, contract:{componentId:c.id, endpointId:null}}); }); }); return {version:SCHEMA_VERSION,screens:screens,components:components,wiring:[]}; } return {version:SCHEMA_VERSION,screens:[],components:[],wiring:[]}; }

  function lintOperation(op){ var errs=[]; if(!op||typeof op!=='object') return ['operation missing']; if(!op.operationId) errs.push('operationId missing'); if(op.operationId && !/^[A-Z]+_\/.+/.test(op.operationId)) errs.push('operationId must match ^[A-Z]+_/path'); if(!op.responses||!op.responses['200']) errs.push('responses["200"] missing'); var r200=op.responses&&op.responses['200']; var hasSchema=!!(r200&&r200.content&&r200.content['application/json']&&r200.content['application/json'].schema); if(!hasSchema) errs.push('200 response must include application/json schema'); return errs; }

  function validateMockAgainstSchema(mock,schema){ try{ if(!schema||typeof schema!=='object') return {ok:true,issues:[]}; var issues=[]; function jsType(x){ if(Array.isArray(x)) return 'array'; if(x===null) return 'null'; return typeof x; } function check(node,sch,path){ if(!sch) return; if(sch.type){ var t=sch.type; var vtype=jsType(node); if(t==='array'){ if(vtype!=='array') issues.push(path+' expected array'); else if(sch.items && node.length>0) check(node[0],sch.items,path+'[0]'); } else if(t==='object'){ if(vtype!=='object') issues.push(path+' expected object'); else if(sch.properties){ Object.keys(sch.properties).forEach(function(k){ if(node[k]!==undefined) check(node[k], sch.properties[k], path+'.'+k); }); } } else { if((t==='integer' && jsType(node)!=='number') || (t!=='integer' && vtype!==t)) issues.push(path+' expected '+t); } } } check(mock,schema,'$'); return {ok:issues.length===0,issues:issues}; }catch(e){ return {ok:false,issues:[String(e)]}; } }

  function parseOverrides(text){ var map={}; (text||'').split('\n').map(function(s){return s.trim();}).filter(Boolean).forEach(function(line){ var idx=line.indexOf('→'); if(idx>-1){ var comp=line.slice(0,idx).trim(); var op=line.slice(idx+1).trim(); if(comp&&op) map[comp]=op; } }); return map; }
  function toKebab(s){ return s.replace(/([a-z])([A-Z])/g,'$1-$2').replace(/_/g,'-').toLowerCase(); }
  function inferEndpoint(comp,settings){ var ov=parseOverrides(settings.mapOverrides||''); var key=(comp.contract&&comp.contract.componentId)||comp.id; if(ov[key]){ var id=ov[key]; var method=id.split('_')[0]; var path=id.replace(/^.*_\//,'/'); return {operationId:id,method:method,path:path,feature:path.replace(/^\//,'').split('/')[0]}; } var root=((comp.contract&&comp.contract.componentId)||comp.id).split(':')[0]; var noun=toKebab(root); var plural=noun.endsWith('s')?noun:noun+'s'; var path='/'+plural; var method=(settings.method||'GET').toUpperCase(); var operationId=method+'_'+path; return {operationId:operationId,method:method,path:path,feature:plural}; }

  function opExists(mw,opId){ for(var p in mw.openapi.paths){ var ops=mw.openapi.paths[p]; for(var m in ops){ if(ops[m].operationId===opId) return true; } } return false; }
  function opById(mw,opId){ for(var p in mw.openapi.paths){ var ops=mw.openapi.paths[p]; for(var m in ops){ if(ops[m].operationId===opId) return {path:p,method:m,op:ops[m]}; } } return null; }

  var MW=loadMW();
  var BE=loadBE();
  var FE=loadFE();
  var SETTINGS=loadSettings();
  var QUEUE=[];
  var PATCH={ features:{}, counts:{ops:0,mocks:0,wiring:0,beFiles:0,errors:0} };

  // SSE Configuration
  const API_BASE = 'http://localhost:3000';
  let eventSource = null;
  
  function startSSE(){
    if (eventSource) eventSource.close();
    eventSource = new EventSource(`${API_BASE}/api/logs/stream`);
    eventSource.onmessage = (ev)=>{
      try{
        const d = JSON.parse(ev.data);
        const line = d.type==='connected'
          ? '[sse] connected'
          : `${new Date(d.ts||Date.now()).toLocaleTimeString()} | ${d.level||'info'} | ${d.opid||''} | ${d.status||''} | ${d.ms||''}ms | ${d.req?.method||''} ${d.req?.path||''}`;
        log(line);
      }catch(e){ /* ignore */ }
    };
  }

  $('#infMethod').value=SETTINGS.method;
  $('#mapOverrides').value=SETTINGS.mapOverrides;
  $('#saveSettings').onclick=function(){ SETTINGS.method=$('#infMethod').value||'GET'; SETTINGS.mapOverrides=$('#mapOverrides').value||''; saveSettings(SETTINGS); };

  $('#scan').onclick=scan;
  $('#autoWire').onclick=buildPatch;
  $('#applyPatch').onclick=applyPatch;
  $('#exportBundle').onclick=exportBundle;
  $('#selfTests').onclick=selfTests;
  $('#reset').onclick=function(){ if(!confirm('Reset all MW/BE/FE local data?')) return; localStorage.removeItem(KEYS.MW); localStorage.removeItem(KEYS.BE); localStorage.removeItem(KEYS.FE); localStorage.removeItem(KEYS.WIRING); MW=loadMW(); BE=loadBE(); FE=loadFE(); QUEUE=[]; renderQueue(); setHealth('warn','Scan to begin'); };
  $('#viewSpec').onclick=function(){ $('#viewer').value=JSON.stringify(MW.openapi,null,2); };
  $('#viewMocks').onclick=function(){ $('#viewer').value=JSON.stringify(MW.mocks,null,2); };
  $('#viewWiring').onclick=function(){ $('#viewer').value=JSON.stringify(loadJSON(KEYS.WIRING, FE.wiring||[]),null,2); };
  $('#viewBE').onclick=function(){ $('#viewer').value=JSON.stringify(BE,null,2); };

  function setHealth(kind,msg){ var h=$('#health'); h.className='status '+(kind||'warn'); h.textContent=msg; }
  function log(m){ var lg=$('#log'); lg.textContent += (typeof m==='string'? m : JSON.stringify(m)) + "\n"; }
  function setTelemetry(){ var c=PATCH.counts; $('#telemetry').textContent='ops: '+c.ops+' | mocks: '+c.mocks+' | wiring: '+c.wiring+' | beFiles: '+c.beFiles+' | errors: '+c.errors; }

  function renderQueue(){ var box=$('#queue'); box.innerHTML=''; if(!QUEUE.length){ box.appendChild(el('div',{class:'muted',text:'Nothing to wire. Run Scan.'})); return; } QUEUE.forEach(function(q){ var c=q.comp; var chk=el('input',{type:'checkbox',checked:true}); var hdr=el('div',{class:'row'},[ chk, el('div',{style:'font-weight:700;flex:1',text:(c.title||c.id)+'  ('+(c.screen||'')+')'}), el('span',{class:'status '+(q.reason.indexOf('Missing')===0?'err':'warn'),text:q.reason}) ]); var infer=inferEndpoint(c,SETTINGS); var sug=el('input',{value:infer.operationId,style:'width:100%'}); hdr.appendChild(el('span',{class:'tag',text:infer.method})); var row=el('div',{class:'listItem'},[ hdr, el('div',{class:'muted',text:'componentId: '+((c.contract&&c.contract.componentId)||c.id)}), el('div',{},[el('div',{class:'muted',text:'Suggested endpointId (edit if needed):'}),sug]) ]); row._chk=chk; row._item=q; row._sug=sug; box.appendChild(row); }); }

  function scan(){ MW=loadMW(); BE=loadBE(); FE=loadFE(); var comps=FE.components||[]; QUEUE=[]; if(!comps.length){ setHealth('err','No components found (FE store empty)'); renderQueue(); return; } comps.forEach(function(c){ var eid=c.contract&&c.contract.endpointId; if(!eid){ QUEUE.push({comp:c,reason:'Missing endpointId'}); return; } if(!opExists(MW,eid)) QUEUE.push({comp:c,reason:'Endpoint not in OpenAPI: '+eid}); }); renderQueue(); setHealth(QUEUE.length? 'warn':'ok', QUEUE.length? (QUEUE.length+' need wiring') : 'All wired'); $('#autoWire').disabled = QUEUE.length===0; }

  function buildPatch(){ PATCH={ features:{}, counts:{ops:0,mocks:0,wiring:0,beFiles:0,errors:0} }; var rows=Array.prototype.slice.call($('#queue').children); rows.forEach(function(r){ if(!(r._chk&&r._chk.checked)) return; var it=r._item; var c=it.comp; var eid=(r._sug&&r._sug.value||'').trim() || (c.contract&&c.contract.endpointId)||''; var method=(eid.split('_')[0]||'GET').toUpperCase(); var path=eid.replace(/^.*_\//,'/'); var feature=(path.replace(/^\//,'').split('/')[0]||'feature'); if(!PATCH.features[feature]) PATCH.features[feature]={ops:[],mocks:[],wiring:[],beFiles:[]}; var exists=opExists(MW,eid); if(!exists){ var op={ operationId:eid, summary:'Auto‑generated for '+((c.contract&&c.contract.componentId)||c.id), tags:[feature], responses:{ '200':{ content:{ 'application/json':{ schema:{ type:'object', properties:{ items:{ type:'array', items:{ type:'object', properties:{ id:{type:'string'}, title:{type:'string'} } } } } } } } } } }; var lints=lintOperation(op); if(lints.length){ PATCH.counts.errors+=lints.length; log({lintErrors:lints,op:eid}); } PATCH.features[feature].ops.push({path:path,method:method.toLowerCase(),op:op}); PATCH.counts.ops++; }
      var mock=MW.mocks[eid] || { items:[{ id:'1', title:(c.title||c.id)+' example' }] }; var found=opById(MW,eid); var schema=(found && found.op && found.op.responses && found.op.responses['200'] && found.op.responses['200'].content && found.op.responses['200'].content['application/json'] && found.op.responses['200'].content['application/json'].schema) || {type:'object'}; var mockCheck=validateMockAgainstSchema(mock,schema); if(!mockCheck.ok){ PATCH.counts.errors+=mockCheck.issues.length; log({mockIssues:mockCheck.issues,op:eid}); } PATCH.features[feature].mocks.push({operationId:eid,payload:mock}); PATCH.counts.mocks++; PATCH.features[feature].wiring.push({ componentId: (c.contract&&c.contract.componentId)||c.id, endpointId: eid, serviceId: feature+'.service#handle', model: feature, fieldMap:{} }); PATCH.counts.wiring++; var files=genFeatureFiles(feature,method,path,eid); Array.prototype.push.apply(PATCH.features[feature].beFiles,files); PATCH.counts.beFiles += files.length; }); renderPatch(); $('#applyPatch').disabled = (PATCH.counts.ops===0 && PATCH.counts.mocks===0 && PATCH.counts.wiring===0 && PATCH.counts.beFiles===0); $('#exportBundle').disabled = $('#applyPatch').disabled; setTelemetry(); }

  function renderPatch(){ var box=$('#patch'), be=$('#bePatch'); box.innerHTML=''; be.innerHTML=''; var feats=Object.keys(PATCH.features); if(!feats.length){ box.appendChild(el('div',{class:'muted',text:'Nothing to change.'})); return; } feats.forEach(function(f){ var grp=PATCH.features[f]; var wrap=el('div',{class:'section'},[ el('div',{style:'font-weight:700',text:'Feature: '+f}), el('div',{class:'tag',text:'ops: '+grp.ops.length}), el('div',{class:'tag',text:'mocks: '+grp.mocks.length}), el('div',{class:'tag',text:'wiring: '+grp.wiring.length}) ]); wrap.appendChild(el('div',{class:'diff',text:JSON.stringify({ops:grp.ops,mocks:grp.mocks,wiring:grp.wiring},null,2)})); box.appendChild(wrap); if(grp.beFiles.length){ be.appendChild(el('div',{class:'section'},[ el('div',{style:'font-weight:700',text:'BE files ('+f+')'}), el('div',{class:'diff',text:grp.beFiles.map(function(x){return x.path;}).join('\n')}) ])); } }); }

  function applyPatch(){ Object.keys(PATCH.features).forEach(function(k){ var grp=PATCH.features[k]; grp.ops.forEach(function(x){ MW.openapi.paths[x.path]=MW.openapi.paths[x.path]||{}; MW.openapi.paths[x.path][x.method]=x.op; }); grp.mocks.forEach(function(m){ MW.mocks[m.operationId]=m.payload; }); }); saveMW(MW); FE.wiring=FE.wiring||[]; Object.keys(PATCH.features).forEach(function(k){ var grp=PATCH.features[k]; grp.wiring.forEach(function(w){ var existing=(FE.wiring||[]).find(function(r){ return r.componentId===w.componentId; }) || (loadJSON(KEYS.WIRING, []).find(function(r){ return r.componentId===w.componentId; })); if(existing){ existing.endpointId=w.endpointId; existing.serviceId=w.serviceId||''; existing.model=w.model||''; existing.fieldMap=existing.fieldMap||{}; } else { FE.wiring.push(clone(w)); } }); }); saveJSON(KEYS.FE,FE); var FS=loadBE(); FS.files=FS.files||{}; Object.keys(PATCH.features).forEach(function(k){ PATCH.features[k].beFiles.forEach(function(f){ FS.files[f.path]=f.content; }); }); saveBE(FS); setHealth('ok','Applied'); log('Applied patch'); $('#exportBundle').disabled=false; $('#applyPatch').disabled=true; $('#autoWire').disabled=true; }

  function exportBundle(){ var bundle={ version:SCHEMA_VERSION, contracts:MW.openapi, mocks:MW.mocks, wiring:FE.wiring||[], backend:loadBE(), timestamp:Date.now() }; var blob=new Blob([JSON.stringify(bundle,null,2)],{type:'application/json'}); var url=URL.createObjectURL(blob); var a=document.createElement('a'); a.href=url; a.download='bundle.tar.json'; a.click(); setTimeout(function(){ URL.revokeObjectURL(url); },300); }

  function selfTests(){ var results=[], failures=0; try{ var errs=[]; for(var p in MW.openapi.paths){ for(var m in MW.openapi.paths[p]){ var op=MW.openapi.paths[p][m]; var e=lintOperation(op); if(e.length) errs.push({op:op.operationId,errors:e}); } } if(errs.length){ failures+=errs.length; results.push({test:'openapi-lint',status:'FAIL',details:errs}); } else results.push({test:'openapi-lint',status:'OK'}); }catch(e){ failures++; results.push({test:'openapi-parse',status:'FAIL',error:String(e)}); }
    try{ var probs=[]; for(var id in MW.mocks){ var found=opById(MW,id); var schema=found&&found.op&&found.op.responses&&found.op.responses['200']&&found.op.responses['200'].content&&found.op.responses['200'].content['application/json']&&found.op.responses['200'].content['application/json'].schema; var v=validateMockAgainstSchema(MW.mocks[id], schema||{}); if(!v.ok) probs.push({op:id,issues:v.issues}); } if(probs.length){ failures+=probs.length; results.push({test:'mock-validate',status:'FAIL',details:probs}); } else results.push({test:'mock-validate',status:'OK'}); }catch(e){ failures++; results.push({test:'mock-validate',status:'FAIL',error:String(e)}); }
    try{ var missing=[]; (FE.components||[]).forEach(function(c){ var key=(c.contract&&c.contract.componentId)||c.id; var row=(FE.wiring||[]).find(function(w){ return w.componentId===key; }); if(!row||!row.endpointId) missing.push(key); }); if(missing.length){ failures+=missing.length; results.push({test:'wiring',status:'FAIL',missing:missing}); } else results.push({test:'wiring',status:'OK'}); }catch(e){ failures++; results.push({test:'wiring',status:'FAIL',error:String(e)}); }
    $('#viewer').value=JSON.stringify({results:results,failures:failures},null,2); setHealth(failures? 'warn':'ok', failures? ('Self‑Tests: '+failures+' issue(s)') : 'Self‑Tests OK'); }

  function cap(s){ return s.charAt(0).toUpperCase()+s.slice(1); }
  function classify(feature){ return feature.split('-').map(cap).join(''); }
  function genFeatureFiles(feature,METHOD,PATH,OPID){ var F=classify(feature), feat=feature.toLowerCase(); var base='apps/api/src/modules/'+feat; var files=[]; files.push({ path: base+'/'+feat+'.controller.ts', content: `import { Controller, ${METHOD==='GET'?'Get':METHOD==='POST'?'Post':METHOD==='PUT'?'Put':METHOD==='PATCH'?'Patch':'Delete'} } from '@nestjs/common';
import { ${F}Service } from './${feat}.service';
import { ApiTags, ApiOkResponse } from '@nestjs/swagger';

@ApiTags('${feat}')
@Controller('${PATH.replace(/^\//,'')}')
export class ${F}Controller {
  constructor(private readonly service: ${F}Service) {}
  ${METHOD==='GET'?'@Get()':'@'+METHOD+'()'}
  @ApiOkResponse({ description: 'Auto‑generated endpoint ${OPID}' })
  async handle(){ return this.service.handle(); }
}
`}); files.push({ path: base+'/'+feat+'.service.ts', content: `import { Injectable } from '@nestjs/common';
@Injectable()
export class ${F}Service {
  async handle(){ return { ok:true }; }
}
`}); files.push({ path: base+'/'+feat+'.module.ts', content: `import { Module } from '@nestjs/common';
import { ${F}Controller } from './${feat}.controller';
import { ${F}Service } from './${feat}.service';
@Module({ controllers:[${F}Controller], providers:[${F}Service] })
export class ${F}Module {}
`}); files.push({ path: base+'/dto/'+F+'Dto.ts', content: `export class ${F}Dto { }
` }); files.push({ path: 'apps/api/mocks/'+OPID+'.json', content: JSON.stringify({ example:{ items:[{ id:'1', title:F+' example'}] } }, null, 2) }); files.push({ path: 'apps/api/prisma/'+feat+'.prisma', content: `// Prisma model skeleton for ${F}
// model ${F} {
//   id String @id @default(cuid())
// }
` }); files.push({ path: 'apps/api/src/app.module.ts', content: `// NOTE: add ${F}Module to AppModule imports.
` }); return files; }

  setHealth('warn','Scan to begin');
  startSSE();
})();
</script>
</body>
</html>
